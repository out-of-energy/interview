# 高级 Java 工程师面试指南

> **候选人：** 10年经验，西安交大本科，长期深耕国网/电力行业  
> **面试时长：** 60-75 分钟  
> **核心考察：** 微服务架构、云原生、工程素养（代码质量/TDD）、数据库原理

---

## 📋 候选人画像速览

| 维度 | 评估 |
|------|------|
| **技术栈** | Spring Cloud → K8s → ES/HBase/知识图谱，演进完整 |
| **优势** | 业务复杂度高，数据量大，架构视野宽 |
| **潜在风险** | ① Mybatis重度用户，JPA可能生疏 ② "云平台部署"是否懂底层原理 ③ 是否有TDD/代码质量意识 |

**面试核心目标：验证他是"能写代码的架构师"还是"只会画PPT的项目经理"**

---

## 🎯 面试流程总览

| 阶段 | 时长 | 重点 |
|------|------|------|
| 1. 破冰与项目概览 | 10分钟 | 快速了解项目背景，判断表达能力 |
| 2. 微服务与Spring生态 | 15分钟 | 服务治理、分布式事务、Spring Boot原理 |
| 3. 容器化与云原生 | 10分钟 | K8s实战深度，区分"会用"vs"懂原理" |
| 4. 工程素养（重点）| 15分钟 | Code Review、单元测试、TDD意识 |
| 5. 数据库原理（红线）| 10分钟 | 索引、事务、锁 —— 一票否决项 |
| 6. API设计与规范 | 10分钟 | RESTful理解深度 |
| 7. 反向提问 | 5分钟 | 观察求职动机 |

---

## 第一部分：破冰与项目概览（10分钟）

### Q1：项目背景介绍

**问法：**
> "请简单介绍一下你最近负责的'国网大数据中心基于数据中台的大数据政务项目'，你在其中承担的角色是什么？最有挑战性的技术难点是什么？"

**观察点：**
- 能否用 2-3 分钟讲清楚项目
- 是偏"技术实现"还是偏"项目管理"
- 挑战点是技术问题还是协调问题

**追问（如果他说得太泛）：**
> "你说拆成了14个微服务，能举一个具体的服务说说它的职责边界吗？当时是怎么决定拆分粒度的？"

**✅ 参考答案要点：**

候选人应能清晰描述：
1. **项目定位**：基于数据中台构建数据产品、数据资源、能力开放等8大业务的前后台功能
2. **技术架构**：微应用+微服务架构，14个微服务+2个微应用，基于SG-UAP开发
3. **他的角色**：是架构设计、核心开发、还是项目管理
4. **技术难点示例**：
   - 微服务拆分粒度的权衡（太细通信成本高，太粗失去意义）
   - 非结构化数据（FastDFS）与结构化数据的统一管理
   - ES全文检索的性能调优
   - 多数据源事务一致性

**🚨 警示信号：**
- 只说"负责整体项目管理"，问技术细节就含糊
- 无法说出任何具体的技术挑战

---

## 第二部分：微服务架构与Spring生态（15分钟）

### Q2：服务容错与熔断

**问法：**
> "在你们的微服务架构中，假设下游的'数据交易服务'突然响应超时，你的系统是如何自我保护的？用的是 Hystrix 还是 Sentinel？"

**✅ 参考答案要点：**

**1. 自我保护策略：**
- **熔断（Circuit Breaking）**：当错误率达到阈值（如50%）直接切断调用，不再请求下游
- **降级（Fallback）**：熔断后返回内存中的默认数据或友好提示
- **隔离（Isolation）**：线程池隔离或信号量隔离，防止一个服务拖垮整个系统

**2. Hystrix vs Sentinel 对比：**
| 维度 | Hystrix | Sentinel |
|------|---------|----------|
| 隔离策略 | 线程池/信号量 | 信号量 |
| 熔断降级 | 基于失败率 | 基于响应时间、异常比例、异常数 |
| 实时监控 | Dashboard | 更强大的控制台 |
| 热点限流 | 不支持 | 支持热点参数限流 |
| 系统保护 | 不支持 | 支持系统自适应保护 |

**3. 高级回答示例：**
> "我们用的 Sentinel。相比 Hystrix，Sentinel 支持热点参数限流，比如可以针对某个热门商品ID单独限流。另外它的系统自适应保护能在CPU负载过高时自动拒绝非核心请求。"

**🎯 评分标准：**
| 段位 | 回答特征 |
|------|----------|
| 初级 | "配置了超时时间和重试" |
| 中级 | "用 Sentinel 做熔断降级，有 Fallback" |
| 高级 | 提到"线程池隔离 vs 信号量隔离"的选择理由，或"热点参数限流" |

**❌ 淘汰信号：** "一般不会超时吧，网络都是内网"

---

### Q3：分布式事务

**问法：**
> "在'电力数据交易平台'中，订单生成和资产划扣跨了多个服务。你们是如何保证数据一致性的？"

**✅ 参考答案要点：**

**1. 主流方案对比：**

| 方案 | 原理 | 适用场景 | 优缺点 |
|------|------|----------|--------|
| **Seata AT模式** | 通过全局锁+Undo Log自动回滚 | 强一致性要求高（如资金） | 开发成本低，性能稍差 |
| **TCC** | Try-Confirm-Cancel三阶段 | 高性能要求 | 开发成本高，需写补偿逻辑 |
| **可靠消息+本地事务表** | 本地事务记录消息，MQ异步通知 | 最终一致性场景 | 性能好，有延迟 |
| **Saga** | 长事务拆分+补偿 | 业务流程长 | 需要设计补偿逻辑 |

**2. 可靠消息方案详解（最常用）：**
```
1. 订单服务开启本地事务
2. 插入订单数据 + 插入消息表（同一事务）
3. 提交事务
4. 发送MQ消息
5. 资产服务消费消息，扣减资产
6. 若失败，通过定时任务扫描消息表重试
```

**3. 追问：消费失败怎么办？如何防止重复消费？**

**期望回答：**
- **幂等性设计**：消费前先查是否已处理过（通过唯一业务ID）
- **去重表**：记录已处理的消息ID
- **死信队列**：多次重试失败后进入死信队列，人工介入

**🎯 评分标准：**
| 段位 | 回答特征 |
|------|----------|
| 初级 | "用数据库事务" |
| 中级 | 知道 Seata 或 消息队列方案 |
| 高级 | 能说清楚方案选型理由 + 幂等性处理 |

---

### Q4：Spring Boot 自动装配

**问法：**
> "你用了这么多年 Spring Boot，能讲讲自动装配的原理吗？如果让你封装一个通用的'日志监控Starter'，核心需要哪些文件？"

**✅ 参考答案要点：**

**1. 自动装配原理：**

```
启动流程：
1. @SpringBootApplication 包含 @EnableAutoConfiguration
2. @EnableAutoConfiguration 导入 AutoConfigurationImportSelector
3. AutoConfigurationImportSelector 调用 SpringFactoriesLoader
4. SpringFactoriesLoader 扫描所有 Jar 的 META-INF/spring.factories
5. 加载其中 EnableAutoConfiguration 对应的配置类
6. 配置类通过 @Conditional 系列注解决定是否生效
```

**2. 自定义 Starter 需要的文件：**

| 文件 | 作用 |
|------|------|
| `XxxAutoConfiguration.java` | @Configuration 配置类，定义 Bean |
| `XxxProperties.java` | @ConfigurationProperties 绑定 application.yml 配置 |
| `META-INF/spring.factories` | 注册配置类（Spring Boot 2.x） |
| `META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports` | 注册配置类（Spring Boot 3.x） |

**3. 关键注解：**
- `@ConditionalOnClass`：某个类存在时才生效
- `@ConditionalOnMissingBean`：容器中没有该 Bean 时才创建
- `@ConditionalOnProperty`：配置属性满足条件时才生效

**4. 高级回答示例：**
> "核心是 SpringFactoriesLoader 的 SPI 机制。我会创建一个 Configuration 类用 @ConditionalOnClass 判断是否引入了日志依赖，用 @ConditionalOnMissingBean 保证用户可以自定义覆盖，然后在 spring.factories 里注册这个配置类。"

**🎯 评分标准：**
| 段位 | 回答特征 |
|------|----------|
| 初级 | "就是加个注解就自动配置了" |
| 中级 | 知道 spring.factories |
| 高级 | 能说清楚完整流程 + Conditional注解的作用 |

**❌ 淘汰信号：** 完全不知道原理，只会用

---

## 第三部分：容器化与云原生（10分钟）

### Q5：K8s 优雅停机

**问法：**
> "你的项目部署在K8s上。当Pod进行滚动更新或OOM重启时，Java应用如何做到对用户请求零中断？Spring Boot需要配置什么来配合K8s探针？"

**✅ 参考答案要点：**

**1. 优雅停机配置（Spring Boot 2.3+）：**

```yaml
# application.yml
server:
  shutdown: graceful  # 开启优雅停机

spring:
  lifecycle:
    timeout-per-shutdown-phase: 30s  # 等待时间
```

**2. 优雅停机流程：**
```
1. K8s 发送 SIGTERM 信号
2. Spring Boot 停止接收新请求
3. 等待正在处理的请求完成（最长30s）
4. 所有请求完成后，应用退出
5. 如果超时，K8s 发送 SIGKILL 强制杀死
```

**3. K8s 探针配置：**

| 探针 | 作用 | Spring Boot Actuator 端点 |
|------|------|---------------------------|
| **Readiness** | 判断是否可以接收流量 | `/actuator/health/readiness` |
| **Liveness** | 判断是否需要重启 | `/actuator/health/liveness` |
| **Startup** | 判断应用是否启动完成 | `/actuator/health/liveness` |

```yaml
# K8s Deployment 配置
readinessProbe:
  httpGet:
    path: /actuator/health/readiness
    port: 8080
  initialDelaySeconds: 10
  periodSeconds: 5
  
livenessProbe:
  httpGet:
    path: /actuator/health/liveness
    port: 8080
  initialDelaySeconds: 30
  periodSeconds: 10
```

**4. 追问：terminationGracePeriodSeconds 设多少？**

**期望回答：**
> "一般设置比 Spring 的 timeout-per-shutdown-phase 稍长，比如35-60秒。因为要给Spring留足时间处理完请求，再留几秒给K8s做清理。"

**🎯 评分标准：**
| 段位 | 回答特征 |
|------|----------|
| 初级 | "用 kill 命令停服务" |
| 中级 | 知道 graceful shutdown |
| 高级 | 能说清楚探针配置 + 时间参数的关系 |

---

### Q6：Docker 镜像优化

**问法：**
> "简历提到'分层构建镜像'。你是如何优化Java应用的Docker镜像体积的？"

**✅ 参考答案要点：**

**1. Multi-stage Build（多阶段构建）：**

```dockerfile
# 阶段1：编译
FROM maven:3.8-openjdk-17 AS builder
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline  # 先下载依赖（利用缓存）
COPY src ./src
RUN mvn package -DskipTests

# 阶段2：运行
FROM eclipse-temurin:17-jre-alpine
COPY --from=builder /app/target/*.jar app.jar
ENTRYPOINT ["java", "-jar", "app.jar"]
```

**2. 优化技巧：**

| 技巧 | 效果 |
|------|------|
| **使用 Alpine/Distroless** | 基础镜像从 500MB 降到 100MB |
| **只用 JRE 不用 JDK** | 运行时不需要编译工具 |
| **Layer Caching** | pom.xml 放在代码前面 COPY，依赖不变时跳过下载 |
| **删除不必要文件** | `.git`, `test`, `docs` 等不要打进镜像 |
| **.dockerignore** | 排除不需要的文件 |

**3. 分层构建原理：**
```
Docker 镜像是分层的，每条指令创建一层
修改代码只会重新构建代码那一层
依赖层可以复用缓存，大幅提升构建速度
```

**4. 高级回答示例：**
> "我用 Multi-stage Build，编译阶段用 Maven 镜像，运行阶段切换到 Alpine JRE。另外把 pom.xml 的 COPY 放在代码 COPY 之前，这样依赖没变时直接用缓存，构建时间从5分钟降到30秒。最终镜像体积从600MB降到了120MB左右。"

**🎯 评分标准：**
| 段位 | 回答特征 |
|------|----------|
| 初级 | "用公司提供的基础镜像" |
| 中级 | 知道 Multi-stage |
| 高级 | 能说清楚 Layer Caching + 具体优化效果 |

**❌ 淘汰信号：** "没怎么优化过，能跑就行"

---

## 第四部分：工程素养（重点！15分钟）

> ⚠️ **这是区分"资深开发"和"码农"的关键环节**

### Q7：Code Review 关注点

**问法：**
> "你们团队做 Code Review 的时候，除了基本的语法错误，你作为高级工程师会重点关注哪些深层次的点？"

**✅ 参考答案要点：**

**1. 三个核心关注维度：**

| 维度 | 具体检查点 |
|------|-----------|
| **可读性** | 命名有业务含义、方法不超过50行、注释说明"为什么"而非"做什么" |
| **潜在Bug** | NPE处理、事务边界、资源关闭、并发安全 |
| **扩展性** | 是否硬编码、是否使用合适的设计模式、是否违反开闭原则 |

**2. 追问：SonarQube/SonarLint 规则**

**问法：**
> "你刚才提到'方法太长'。你们有没有用 SonarQube 或 SonarLint？你最痛恨、必须让组员改掉的规则是哪几条？"

**期望回答的规则：**

| 规则 | 说明 | 为什么重要 |
|------|------|-----------|
| **Cognitive Complexity** | 认知复杂度过高（嵌套太深） | 代码难以理解和维护 |
| **Resource Leak** | 资源未关闭（流、连接） | 导致内存泄漏、连接池耗尽 |
| **Magic Number** | 魔法值（直接写数字） | 不知道含义，改起来漏改 |
| **Duplicate Code** | 重复代码 | 改一处漏另一处 |

**3. 高级回答示例：**
> "语法错误 IDE 就能发现，不需要 CR。我重点看三个：第一是认知复杂度，超过15的方法我直接打回；第二是事务注解的位置，private方法加@Transactional是无效的；第三是并发安全，比如在for循环里调用远程接口没有做批量优化。"

**🎯 评分标准：**
| 段位 | 回答特征 |
|------|----------|
| 初级 | "看看有没有报错" |
| 中级 | 知道要看命名和逻辑 |
| 高级 | 提到具体的复杂度指标 + 真实案例 |

**❌ 淘汰信号：** "我们一般就看看有没有标红"

---

### Q8：重构与测试（TDD核心）

**问法：**
> "假设有一坨5层 if-else 的旧代码需要你重构。你如何保证重构不会把原本正确的逻辑改坏？你怎么敢放心地提交？"

**✅ 参考答案要点：**

**1. 核心思路（测试先行）：**

```
正确流程：
1. 先检查是否有现成的单元测试
2. 如果没有，先补写测试用例，把当前逻辑"固定"住
3. 运行测试，确保全绿
4. 开始重构
5. 每改一小步就跑测试
6. 最终测试全绿，才敢提交
```

**2. 这就是 TDD 的雏形！**

> **关键洞察**：他不需要说"我是TDD专家"，但他知道**"先有测试，才有重构的安全感"**，这就是你想要的意识。

**3. 追问：如何让代码"容易被测试"？**

**问法：**
> "老系统代码耦合很重，Service里直接new了很多对象。你平时写新代码时，怎么设计才能让它'容易被测试'？"

**期望回答：**

| 原则 | 说明 | 测试时的好处 |
|------|------|-------------|
| **依赖注入（DI）** | 不在方法内部 new 对象，通过构造器/Setter注入 | 可以注入 Mock 对象 |
| **面向接口编程** | 依赖接口而非实现 | 可以用 Mockito Mock 接口 |
| **单一职责** | 一个类只做一件事 | 测试范围小，好写 |

**4. 高级回答示例：**
> "仅靠肉眼检查是不敢保证的。重构前我会先看有没有配套的单元测试，如果没有，我会先补一个测试把现有逻辑跑通。等测试变绿了再去改代码，改完再跑测试，绿了才提交。
>
> 至于新代码，我会确保依赖都是注入的，不在方法里 new HttpClient 或 Dao。这样测试时用 Mockito mock 掉外部依赖，只测我自己的业务逻辑。"

**🎯 评分标准：**
| 段位 | 回答特征 |
|------|----------|
| 初级 | "小心点改，多测几遍" |
| 中级 | "改完部署到测试环境验证" |
| **高级** | **"重构前先补测试"** + 知道依赖注入便于 Mock |

**❌ 淘汰信号：** "重构靠细心，测试靠手点"

---

## 第五部分：数据库原理（红线！10分钟）

> ⚠️ **这三个问题是一票否决项。答不上来，其他再好也要慎重。**

### Q9：事务传播机制（必问）

**问法：**
> "假设 Service A 的事务方法里调用了 Service B 的事务方法。如果 B 抛了异常，但 A 把它 try-catch 捕获了，请问 A 的数据会回滚吗？为什么？"

**✅ 参考答案要点：**

**1. 正确答案：会回滚（或抛 UnexpectedRollbackException）**

**2. 原理解释：**
```
默认传播机制是 REQUIRED（加入当前事务）
→ A 和 B 共用同一个事务
→ B 抛异常时，事务被标记为 rollback-only
→ A 虽然 catch 了异常，但事务已被标记
→ A 方法结束时尝试 commit，发现 rollback-only
→ 要么回滚，要么抛 UnexpectedRollbackException
```

**3. 七种传播机制：**

| 传播机制 | 行为 |
|----------|------|
| **REQUIRED**（默认） | 有事务就加入，没有就新建 |
| **REQUIRES_NEW** | 总是新建事务，挂起当前事务 |
| **NESTED** | 嵌套事务（保存点） |
| **SUPPORTS** | 有事务就加入，没有就不用事务 |
| **NOT_SUPPORTED** | 以非事务方式执行，挂起当前事务 |
| **MANDATORY** | 必须有事务，否则抛异常 |
| **NEVER** | 必须没有事务，否则抛异常 |

**4. 解决方案：**
- 如果希望 B 的失败不影响 A：让 B 使用 `@Transactional(propagation = REQUIRES_NEW)`
- 这样 B 会开启独立事务，B 回滚不影响 A

**5. 高级回答示例：**
> "会回滚。因为默认传播机制是 REQUIRED，A 和 B 共用一个事务。B 抛异常时把事务标记为 rollback-only，A 就算 catch 了也没用，最后 commit 时会发现这个标记，要么回滚要么抛 UnexpectedRollbackException。如果想让 B 失败不影响 A，可以让 B 用 REQUIRES_NEW 开启独立事务。"

**🎯 评分标准：**
| 段位 | 回答特征 |
|------|----------|
| **正确** | 知道会回滚 + 能解释 rollback-only |
| **加分** | 知道 REQUIRES_NEW 的解决方案 |
| **❌ 一票否决** | "Catch住了就不回滚吧？" |

---

### Q10：乐观锁 vs 悲观锁

**问法：**
> "两个管理员同时修改同一份'招标书'，怎么防止后提交的人覆盖先提交的人的修改？你会用 `for update` 还是 Version 字段？"

**✅ 参考答案要点：**

**1. 两种锁对比：**

| 维度 | 悲观锁 (for update) | 乐观锁 (Version) |
|------|---------------------|------------------|
| **原理** | 查询时加排他锁，其他事务等待 | 更新时检查版本号是否变化 |
| **性能** | 低（有等待） | 高（无锁） |
| **适用场景** | 冲突多、写多读少 | 冲突少、读多写少 |
| **实现** | `SELECT ... FOR UPDATE` | `@Version` 注解 |

**2. 乐观锁实现（JPA）：**

```java
@Entity
public class Document {
    @Id
    private Long id;
    
    @Version  // 每次更新自动+1
    private Integer version;
    
    private String content;
}

// 更新时自动检查版本
// UPDATE document SET content=?, version=version+1 
// WHERE id=? AND version=?
// 如果版本不匹配，抛出 OptimisticLockException
```

**3. 选型建议：**

| 场景 | 推荐方案 |
|------|----------|
| 后台管理系统（冲突少） | 乐观锁 @Version |
| 秒杀/抢购（冲突多） | Redis 分布式锁 或 数据库悲观锁 |
| 库存扣减 | 乐观锁 + 重试 或 `UPDATE stock SET count=count-1 WHERE count>=1` |

**4. 高级回答示例：**
> "对于后台管理系统，我会用 JPA 的 @Version 乐观锁。因为管理系统读多写少，冲突概率低，乐观锁性能好、代码无侵入。如果是秒杀场景，冲突率极高，乐观锁会一直重试失败，这时候要用 Redis 分布式锁或者数据库悲观锁。"

**🎯 评分标准：**
| 段位 | 回答特征 |
|------|----------|
| 初级 | 只知道一种 |
| 中级 | 知道两种区别 |
| 高级 | 能根据场景选型 |
| **❌ 一票否决** | "没遇到过，数据库应该会处理吧？" |

---

### Q11：索引失效场景

**问法：**
> "有一个联合索引 `(create_time, status, amount)`。  
> 查询1：`WHERE status = 'PAID' AND amount > 100`，索引生效吗？  
> 查询2：`WHERE create_time > '2025-01-01' ORDER BY amount`，会有 Filesort 吗？"

**✅ 参考答案要点：**

**1. 正确答案：**

| 查询 | 结论 | 原因 |
|------|------|------|
| 查询1 | ❌ 不生效 | 跳过了最左边的 create_time，违反最左前缀原则 |
| 查询2 | ❌ 会 Filesort | create_time 是范围查询，后面的列无法使用索引排序 |

**2. 最左前缀原则：**
```
联合索引 (A, B, C) 可以支持：
✅ WHERE A = ?
✅ WHERE A = ? AND B = ?
✅ WHERE A = ? AND B = ? AND C = ?
❌ WHERE B = ?（跳过A）
❌ WHERE B = ? AND C = ?（跳过A）
```

**3. 范围查询后索引失效：**
```
WHERE A > ? ORDER BY B
A 用了范围查询（>, <, BETWEEN, LIKE 'xx%'）
B 无法使用索引排序
会产生 Filesort（文件排序）
```

**4. 追问：慢SQL排查**

**问法：**
> "线上慢SQL，Explain显示全表扫描（type=ALL），除了加索引还会检查什么？"

**期望回答：**

| 检查点 | 说明 |
|--------|------|
| **区分度太低** | 比如 gender 只有男/女，加索引也没用 |
| **函数运算** | `WHERE YEAR(create_time) = 2024` 索引失效 |
| **隐式类型转换** | 字段是 varchar，查询用 int，索引失效 |
| **LIKE 前置%** | `LIKE '%keyword'` 索引失效 |
| **OR 条件** | `WHERE a=1 OR b=2`，如果b没索引，全表扫描 |

**5. 高级回答示例：**
> "第一个不生效，因为跳过了最左边的 create_time。第二个会 Filesort，因为 create_time 是范围查询，后面的 amount 无法用索引排序。
> 
> 排查慢SQL除了加索引，我还会检查：字段区分度是否太低、是否对字段做了函数运算（比如YEAR()）、是否有隐式类型转换（varchar字段用int查询）。"

**🎯 评分标准：**
| 段位 | 回答特征 |
|------|----------|
| 初级 | 只知道"加索引" |
| 中级 | 知道最左前缀 |
| 高级 | 能分析范围查询 + 知道失效场景 |

---

## 第六部分：API 设计与 RESTful 规范（10分钟）

### Q12：取消订单接口设计

**问法：**
> "设计一个'取消订单'的接口，URL 和 HTTP Method 怎么设计？"

**✅ 参考答案要点：**

| 段位 | 设计 | 评价 |
|------|------|------|
| 初级 | `POST /api/cancelOrder?id=123` | RPC风格，把HTTP当传输通道 |
| 中级 | `DELETE /api/orders/123` | 合理，但"取消"不等于"物理删除" |
| **高级** | `PATCH /api/orders/123` + `{"status":"CANCELLED"}` | ✅ 理解REST本质是"资源状态操作" |

**核心理解：**
- REST 是"对资源状态的操作"，不是"动作的映射"
- URL 应该是名词（orders），不是动词（cancelOrder）
- "取消"是状态变更，用 PATCH 修改状态字段

---

### Q13：复杂查询设计

**问法：**
> "高级搜索接口，用户要筛选几十个条件，还坚持用 GET 吗？"

**✅ 参考答案要点：**

**问题：**
- GET 请求有 URL 长度限制（约2000-8000字符）
- 复杂查询条件拼进 URL 会超限

**解决方案：**
```
POST /api/orders/search
Content-Type: application/json

{
  "startDate": "2025-01-01",
  "endDate": "2025-01-31",
  "status": ["PAID", "SHIPPED"],
  "minAmount": 1000,
  "customerId": 12345
}
```

**注意事项：**
- 这个 POST 只是为了承载复杂参数，语义上仍是查询
- 如果需要缓存，可能要特殊处理（POST 默认不缓存）

---

### Q14：API 版本兼容

**问法：**
> "接口返回的 `user` 字段要从字符串改成对象，但旧版App还在用。如何平滑升级？"

**✅ 参考答案要点：**

| 方案 | 实现 | 优缺点 |
|------|------|--------|
| **URL版本** | `/api/v1/orders` → `/api/v2/orders` | 最直观，维护成本高 |
| **扩展字段** | 保留 `user`，新增 `userInfo` 对象 | 数据冗余换兼容，实用 |
| **Header版本** | `Accept-Version: v2` | 学术派，调试麻烦 |

**高级回答示例：**
> "我优先用URL版本号，因为直观且对缓存友好。如果只是小改动，可以用扩展字段——保留原来的 user 字段，新增 userInfo 对象，让新旧客户端各取所需。"

**❌ 淘汰回答：** "直接改了，通知前端改代码"（无线上运维意识）

---

## 第七部分：反向提问（5分钟）

> "你有什么想问我的？"

**观察点：**

| 问题类型 | 评价 |
|----------|------|
| 问技术栈/架构 | 真正想做事，技术驱动 |
| 问团队/文化 | 关注成长环境 |
| 问业务方向 | 有全局思维 |
| 只问薪资/加班 | 正常，但优先级说明态度 |
| 不问 | 可能不太在意这个机会 |

---

## 📊 最终评分表

| 维度 | 权重 | 优秀标准 | 得分 |
|------|------|----------|------|
| **技术深度** | 25% | 讲清 Spring Cloud、K8s 原理，能排查线上问题 | /10 |
| **工程素养** | **30%** | 有代码洁癖，坚持单元测试，熟练使用 Sonar | /10 |
| **数据库原理** | **20%** | 事务传播、锁、索引失效必须答对 | /10 |
| **架构能力** | 15% | 能画清楚架构图，说清拆分理由 | /10 |
| **沟通表达** | 10% | 逻辑清晰，不绕弯子 | /10 |

**加权总分：_______ / 10**

---

## 🚨 红线清单（一票否决）

- [ ] 事务传播机制完全不懂（Q9）
- [ ] 不知道乐观锁/悲观锁区别（Q10）
- [ ] 从未写过单元测试，重构靠"细心"（Q8）
- [ ] API版本兼容靠"通知前端改代码"（Q14）
- [ ] 问到微服务容错说"一般不会出问题"（Q2）

---

## 💡 面试官备注区

```
=== 整体印象 ===
项目深度：
技术广度：
代码质量意识：
沟通表达：

=== 亮点 ===


=== 顾虑 ===


=== 综合评价 ===


是否录用建议：[ ] 强烈推荐  [ ] 推荐  [ ] 待定  [ ] 不推荐

原因：
```
