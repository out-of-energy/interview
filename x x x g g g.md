# Zoom 面试文档（Java 后端）- 谢戈

> **时长**：30–35 分钟（无现场编码）  
> **目标**：验证 Java 基础是否扎实、Spring Boot 是否真熟练、是否理解 Spring Data JPA 基本概念、RESTful 设计是否靠谱、数据库基础是否过线。  
> **用法**：每题先问“主问题”；回答泛就用“追问钉子”；答得好就跳下一块控时。

---

## 评分卡（建议现场打分）

- **Java 基础（/10）**：集合/并发/线程池基础与常见坑
- **Spring Boot（/10）**：事务、代理/自调用、自动配置理解深度
- **数据库（/10）**：索引与联合索引、隔离级别、慢 SQL 排查
- **Spring Data JPA（/10）**：LAZY/EAGER、N+1、常见解决方案
- **RESTful（/10）**：资源建模、幂等、状态码、错误返回规范

### 一票否决（出现任一条建议直接不通过）

- 事务回滚规则/传播机制完全讲不清
- 联合索引最左前缀与常见索引失效场景完全不懂
- 隔离级别与脏读/不可重复读/幻读关系完全混乱
- REST 方法语义（GET/POST/PUT/PATCH/DELETE）严重错误且无法纠正

---

## 0–3 分钟：开场与验真定位

### Q0：最近一次后端经历（验真必问）

- **问**：你最近一次在生产做 Java/Spring Boot 后端是什么时候？做了哪些接口/模块？你负责设计、开发还是排障？
- **追问钉子**：挑一个你最熟的接口，说清楚：
  - 入参与校验（有哪些必填/边界条件）
  - 事务边界（哪里开事务，为什么）
  - 大概涉及哪些表/字段（不要求全背，但要能说关键表）
  - 异常怎么处理、如何返回给前端
- **通过标准**：能给出具体细节（接口/表/事务/问题），不是“参与过/了解”。
- **红旗**：全程抽象描述，问细节就转移话题。

#### 参考答案要点（你用来判断“是否真实做过”）

- **至少要说清 4 件事**：
  - **接口/模块**：具体做的是“订单/用户/权限/搜索/报表/任务”等哪类，不要只说“做后台”
  - **数据模型**：说得出 1–2 张核心表（或核心实体）及关键字段（如状态、金额、版本号等）
  - **事务边界**：在哪个 Service 方法开事务、为什么要事务（跨多表写、保证一致性）
  - **异常/返回**：如何把业务异常转换成统一错误码/状态码（或至少有全局异常处理思路）
- **加分点**：能说出一次真实线上问题（慢 SQL、死锁、事务回滚、超时、连接池耗尽）以及定位路径。
- **常见误区/红旗**：
  - 只讲架构名词（微服务/中台/DDD）但说不出任何接口与表
  - 事务边界含糊（“都加 @Transactional 就行”）

---

## 3–11 分钟：Java 基础（选 2 题，8 分钟）

> 候选人如果自称“Java 很强”，这里要适当追深；如果明显偏前端背景，这里更像“快速验真”。

### Q1：HashMap + equals/hashCode

- **问**：HashMap 查找 key 的过程是什么？为什么重写 equals 必须重写 hashCode？
- **追问钉子**：key 放进 Map 后，key 的参与 hash/equals 的字段被改了，会发生什么？
- **通过标准**：
  - 说清：hash 定位桶 + equals 决定是否同一个 key
  - 知道：改 key 会导致“找不到/出现重复/数据不可预期”

#### 参考答案要点

- **HashMap 查找**：`hash(key)` → 定位桶（数组下标）→ 桶内链表/红黑树用 `equals` 比较找到目标 entry。
- **必须同时重写**：相等对象（equals=true）必须有相同 hashCode，否则会落到不同桶，导致**查不到/出现重复 key**。
- **key 变更后果**：key 的 hash/equals 参与字段变了，会导致该 entry 处于“错误桶”，**get 查不到、remove 删不掉**。
- **加分点**：提到 JDK8 链表树化、扩容 rehash/resize 的基本概念即可。
- **常见误区**：把 equals 当成“唯一标准”，忽略 hashCode 参与定位。

### Q2：并发基础（volatile / 原子性）

- **问**：volatile 解决什么问题？能保证 `i++` 线程安全吗？
- **追问钉子**：AtomicInteger 为什么可以？（说清 CAS/自旋重试即可）
- **通过标准**：
  - 说清可见性/有序性；不保证复合操作原子性
  - 能解释 Atomic 基于 CAS 的思路

#### 参考答案要点

- **volatile**：保证**可见性** + 一定程度的**禁止指令重排序**；**不保证原子性**。
- **`i++`**：读-改-写是复合操作，volatile 也可能丢更新，**不线程安全**。
- **AtomicInteger**：CAS（比较并交换）+ 自旋重试保证原子更新；底层依赖 CPU 原子指令。
- **加分点**：能说出 synchronized 解决原子性/互斥，volatile 不提供互斥。
- **常见误区**：认为“volatile 就是轻量级锁/能解决一切并发问题”。

#### 备选（时间允许才问）：线程池

- **问**：你通常怎么配置线程池？拒绝策略你选哪一个，为什么？
- **追问钉子**：无界队列的风险是什么？
- **通过标准**：知道无界队列可能 OOM；拒绝策略含义说对即可（不要求背全）。

#### 参考答案要点（备选）

- **关键参数**：core/max/queue/keepAlive/reject；能解释“为什么这样设”即可。
- **无界队列风险**：任务堆积导致内存压力/最终 OOM，且可能“看起来线程没满但延迟越来越高”。
- **拒绝策略**：Abort/CallerRuns/Discard/DiscardOldest；生产常见选择要能讲清取舍（例如 CallerRuns 回压）。
- **加分点**：不同业务隔离不同线程池；为下游依赖设置超时与舱壁隔离思路。

---

## 11–21 分钟：Spring Boot（核心验真，10 分钟）

### Q3：事务（红线）

- **问**：`@Transactional` 默认回滚规则是什么？checked exception 回滚吗？
- **追问钉子**：A（有事务）调用 B（也标事务），B 抛异常但被 A catch 住，最后会回滚吗？为什么？
- **通过标准**：
  - 默认：RuntimeException/Error 回滚；checked exception 默认不回滚（除非 rollbackFor）
  - 能说清：默认传播 REQUIRED，共用事务；异常可能导致事务被标记 rollback-only，最终回滚/或抛 UnexpectedRollback

#### 参考答案要点

- **默认回滚**：遇到 `RuntimeException`/`Error` 回滚；**checked exception 默认不回滚**（可通过 `rollbackFor` 指定）。
- **A 调 B + catch**：默认传播 **REQUIRED**，A/B 共用事务；B 抛运行时异常通常会把事务标记为 **rollback-only**，即使 A catch，最终提交时也会回滚，可能抛 `UnexpectedRollbackException`。
- **加分点**：能说出 `REQUIRES_NEW`（B 独立事务）以及业务上什么时候需要。
- **常见误区/红旗**：
  - “catch 住就不回滚了”
  - 不知道 checked/unchecked 的默认差异

### Q4：自调用导致事务失效（高频坑）

- **问**：同一个类里 A 调 B，B 上 `@Transactional` 为什么可能不生效？
- **追问钉子**：你怎么修？
- **通过标准**：理解代理机制；修复办法说出一种即可（拆到另一个 Bean/通过代理调用等）。

#### 参考答案要点

- **原因**：Spring 事务基于 AOP 代理；同类内部调用是 `this.b()`，不会经过代理，事务拦截器不生效。
- **常见修法**（说出一种即可）：
  - 把 B 拆到另一个 `@Service`，由 Spring 注入后调用
  - 通过代理对象调用（例如从容器拿到自身代理；或 `AopContext.currentProxy()`，前提开启相关配置）
- **加分点**：能补充“private 方法事务不生效/最终方法代理限制”等常见坑。

### Q5：自动配置（熟练度分水岭）

- **问**：Spring Boot 自动配置大概怎么工作的？你用过哪些 `@Conditional...`？
- **追问钉子**：如果让你做一个 starter，大概需要哪些关键东西？
- **通过标准**：
  - 说清：根据 classpath/配置/条件创建 Bean
  - 能举 1–2 个 Conditional 或说明 starter 由 AutoConfiguration + Properties + 注册机制构成

#### 参考答案要点

- **核心机制**：Boot 在启动时加载一批 AutoConfiguration（来自注册清单），并通过 `@Conditional...` 判断是否生效。
- **常见 Conditional**（举 1–2 个即可）：
  - `@ConditionalOnClass`：类存在才装配
  - `@ConditionalOnProperty`：配置满足条件才装配
  - `@ConditionalOnMissingBean`：用户未自定义才创建默认 Bean
- **starter 组成（讲大概即可）**：
  - `XxxAutoConfiguration`（定义 Bean）
  - `XxxProperties` + `@ConfigurationProperties`（绑定配置）
  - 注册文件（Boot2 的 `spring.factories` 或 Boot3 的 `AutoConfiguration.imports`）
- **常见误区**：只会说“加依赖就自动好了”，完全解释不出“为何能自动”。

---

## 21–30 分钟：数据库（必须考察，9 分钟）

### Q6：索引与联合索引（红线）

- **问**：联合索引 `(a, b, c)` 什么情况下能用？什么叫最左前缀？
- **追问钉子**：
  - `WHERE b = ? AND c = ?` 为什么通常用不上该联合索引？
  - `WHERE a > ? ORDER BY b` 可能发生什么？（排序/回表/Extra）
- **通过标准**：
  - 解释最左前缀原则正确
  - 知道范围条件后，后续列可能无法继续用于排序/过滤（可能 filesort）

#### 参考答案要点

- **最左前缀**：联合索引 `(a,b,c)` 能用在 `a` 开头的过滤上：
  - ✅ `a=?`
  - ✅ `a=? and b=?`
  - ✅ `a=? and b=? and c=?`
  - ❌ 跳过 a：`b=?` / `b=? and c=?` 通常用不上该索引
- **范围条件影响**：一旦 `a` 是范围（`> < between like 'x%'`），后续列通常**无法继续用于排序/进一步过滤**，`ORDER BY b` 可能出现 **filesort**。
- **加分点**：能提到覆盖索引/回表（Extra 里的 Using index 等）。
- **常见误区**：认为“联合索引里包含 b/c，所以 `where b=?` 也能用”。

### Q7：事务隔离级别（脏读/不可重复读/幻读）

- **问**：四种隔离级别分别解决什么问题？（Read Uncommitted / Read Committed / Repeatable Read / Serializable）
- **追问钉子**：MySQL(InnoDB) 默认隔离级别？可重复读下如何避免幻读？（间隙锁/Next-Key Lock 思路即可）
- **通过标准**：
  - 能把脏读/不可重复读/幻读与隔离级别大致对应
  - 默认 RR（答对加分）；能提到 Next-Key/间隙锁（加分）

#### 参考答案要点

- **现象定义**：
  - **脏读**：读到未提交数据
  - **不可重复读**：同一行两次读结果不同（被其他事务提交更新）
  - **幻读**：同一条件两次查，行数变化（被其他事务插入/删除导致）
- **隔离级别与现象**（能讲对大概即可）：
  - RU：可能脏读/不可重复读/幻读
  - RC：避免脏读；仍可能不可重复读/幻读
  - RR：避免脏读/不可重复读；幻读在实现上通过锁机制尽量避免
  - Serializable：最强，串行化
- **MySQL(InnoDB) 默认**：通常是 **Repeatable Read**（RR）。
- **加分点**：提到 Next-Key Lock/间隙锁用于避免幻读的思路。
- **常见误区**：把“幻读”和“不可重复读”混为一谈，或只背名称不知含义。

### Q8：慢 SQL 排查（务实）

- **问**：线上慢 SQL 你怎么排查？Explain 重点看哪些列？
- **追问钉子**：哪些写法会导致索引失效？举 2 个。
- **通过标准**：
  - Explain 说出 2–3 个关注点即可：type、key、rows、Extra
  - 索引失效举例正确：对列做函数、隐式类型转换、前置 `%LIKE`、OR、低区分度等

#### 参考答案要点

- **排查路径（讲出 3 步即可）**：
  - 先看慢 SQL 日志/监控定位具体语句与耗时
  - Explain 看执行计划：是否走索引、扫描行数是否异常、Extra 是否 filesort/temporary
  - 再决定：改 SQL/加或调索引/拆分查询/加缓存（最后才是缓存）
- **Explain 常看**（说出 2–3 个即可）：
  - `type`（ALL/INDEX/RANGE/REF/CONST…）
  - `key`（用到哪个索引）
  - `rows`（预估扫描行数）
  - `Extra`（Using filesort / Using temporary / Using index）
- **索引失效常见原因（举 2 个即可）**：
  - 对列做函数/表达式（如 `YEAR(create_time)=...`）
  - 隐式类型转换（varchar 用数字查等）
  - `LIKE '%xx'` 前置 %
  - OR 条件导致走不了索引
- **红旗**：只会说“加索引/加缓存”，说不出任何执行计划依据。

---

## 30–34 分钟：JPA + REST（4 分钟，快速确认“了解且不误用”）

### Q9：JPA 的 LAZY/EAGER 与 N+1（必问）

- **问**：什么是 N+1？LAZY/EAGER 怎么选？怎么解决 N+1？
- **通过标准**：
  - 解释 N+1：主表 1 次查询 + 关联集合 N 次查询
  - 解决方案能说出任意一种：fetch join / EntityGraph / DTO 投影 / 批量抓取（batch size）

#### 参考答案要点

- **LAZY vs EAGER**：
  - LAZY：用到关联时再查；更可控，但不注意会触发 N+1
  - EAGER：查询主实体时立刻抓关联；可能导致查询巨大/重复数据
- **N+1**：查 1 次主表，再为每条记录额外查 1 次关联（总计 1+N 次）。
- **解决方案（说出 1 个即可）**：
  - JPQL/Criteria 的 fetch join
  - `@EntityGraph` 指定抓取图
  - DTO 投影（只查需要的字段）
  - batch size/批量抓取（Hibernate）
- **常见误区**：一律把关系改成 EAGER 来“修复”，导致性能更差。

### Q10：RESTful 设计（接口素养）

- **题**：设计“取消订单”接口（URL + method + 状态码）。
- **追问钉子**：
  - 取消是否幂等？重复调用怎么返回？
  - 订单已完成不可取消，返回什么？（409/422 等，说明理由即可）
- **通过标准**：
  - 资源名词化：`/orders/{id}`
  - 取消属于状态变更：PATCH 修改 status，或 POST 子资源（能解释语义即可）
  - 状态码至少合理说出：200/204、404、409（或 422）

#### 参考答案要点

- **推荐设计（示例）**：
  - `PATCH /orders/{id}` body：`{"status":"CANCELLED"}`（取消是“状态变更”）
  - 或 `POST /orders/{id}/cancellation`（子资源风格，能自洽也可）
- **幂等性**：重复取消应当**幂等**（第二次仍返回成功或返回“已取消”状态），避免客户端重试造成异常副作用。
- **状态码建议**：
  - 404：订单不存在
  - 409（或 422）：状态冲突/不允许取消（如已完成）
  - 200/204：取消成功（或返回最新订单状态）
- **加分点**：提到统一错误响应结构（errorCode/message/traceId）与全局异常处理（ControllerAdvice）。

---

## 34–35 分钟：反问 + 当场结论

- **让候选人反问 30 秒**（观察关注点：技术/业务/团队/成长）
- **你总结 30 秒**：
  - 强项：
  - 风险点：
  - 建议：**强推 / 推 / 待定 / 不推**（一句话原因）

---

## 面试官速记区（建议直接复制粘贴在文末记录）

```
Q0 验真：____________________________________________________
Java：HashMap/并发（/10）：___________________________________
Spring Boot：事务/代理/自动配置（/10）：_____________________
数据库：索引/隔离级别/慢SQL（/10）：_________________________
JPA：N+1/抓取策略（/10）：___________________________________
REST：资源/幂等/状态码（/10）：______________________________

亮点：_______________________________________________________
风险：_______________________________________________________
结论：[ ] 强推  [ ] 推  [ ] 待定  [ ] 不推
一句话原因：_________________________________________________
```
