
### 面试场景脚本：从 Code Review 到 TDD 的连环追问

**面试官（你）：**
“我看你的项目经验非常丰富，做过很多核心模块。我想聊聊你们团队的协作习惯。
**Q1：你们在做 Code Review（代码评审）的时候，除了看基本的语法错误，你作为高级工程师，会重点关注哪些深层次的点？**”

---

#### **第一层：考察代码审美与架构意识**

**候选人（理想回答）：**
“如果是简单的语法，一般 IDE 就提示了，不需要 CR 来看。我在 CR 时主要关注几点：

1. **代码的可读性：** 命名是不是有业务含义，方法是不是太长了。
2. **潜在的 Bug：** 比如空指针异常（NPE）的处理，事务控制在异常捕获时会不会失效。
3. **扩展性：** 比如这里是不是把逻辑写死了，下次业务变了需不需要大改，有没有用到合适的设计模式。”

**面试官（你）—— *【引出自动化工具】*：**
“很好。你刚才提到‘方法是不是太长’或者‘逻辑太复杂’。
**Q2：这种依靠人眼去看有时候会疲劳或者标准不统一。你们有没有引入什么静态代码扫描工具（比如 SonarQube 或 SonarLint）来辅助 CR？如果有，你最痛恨甚至会‘强迫’组员必须修改的规则是哪几条？**”

---

#### **第二层：考察对“代码质量标准”的具体认知**

**候选人（理想回答）：**
“我们用过 Sonar。我个人最看重的是**‘圈复杂度’（Cyclomatic Complexity）**或者**‘认知复杂度’**。
如果一个方法里嵌套了 4、5 层 if-else，哪怕逻辑是对的，我也会打回去让他重构，因为这以后没法维护。还有就是**资源未关闭**和**魔法值（Magic Number）**，这是我的红线。”

* **⚠️ 你的观察点：**
* **加分：** 能说出具体的指标（如“复杂度”、“重复率”），说明他真的在用，而且有标准。
* **减分：** 支支吾吾，或者只说“就看看有没有标红”，说明只是为了应付检查。



**面试官（你）—— *【引出重构与单元测试】*：**
“说得对，高复杂度的代码确实是维护噩梦。那如果让你把这坨 5 层 if-else 的旧代码重构成干净的代码（比如用策略模式）：
**Q3：你如何保证你的重构不会把原本正常的业务逻辑改坏了？你怎么敢放心地提交这次重构？**”

---

#### **第三层：考察“测试为导向”的意识（TDD 的核心）**

**候选人（理想回答）：**
“仅靠肉眼检查是不敢保证的。
在重构前，我会先看这段代码有没有配套的**单元测试（Unit Test）**。如果没有，我会**先补写一个测试用例**，把现在的逻辑跑通，‘固定’住现场。
等测试变绿了，我再去改代码。改完后再跑一遍测试，只要测试还是绿的，我就有底气提交了。”

* **⚠️ 你的观察点（关键）：**
* 这就是你想要的**“意识”**！他不需要说“我是 TDD 专家”，但他知道**“先有测试，才有重构的安全感”**，这就是 TDD 的雏形。



**面试官（你）—— *【终极一问：验证可测试性设计】*：**
“非常专业的做法。但我们都知道，老旧系统的代码很难写测试，因为耦合太重（比如在 Service 里直接 new 了很多对象，或者强依赖数据库）。
**Q4：为了让你刚才说的‘补写测试’变得容易，你在平时写新代码（比如设计一个新的 Service）时，会怎么设计代码结构，让它天生就‘容易被测试’？**”

---

#### **第四层：考察高级设计能力（依赖注入与 Mock）**

**候选人（理想回答）：**
“这就涉及到代码的**‘可测试性’（Testability）**了。

1. **依赖注入（DI）：** 我绝对不会在方法内部去 `new` 一个 HttpClient 或者 Dao，一定要通过 Spring 注入进来。
2. **面向接口编程：** 依赖接口而不是实现。
这样我在写单元测试时，就可以利用 Mockito 这种工具，把数据库、外部接口这些‘不好测’的依赖 Mock 掉，只测我自己的业务逻辑。如果代码耦合度太高，根本没法 Mock，那测试也就写不下去了。”

---

### **总结：如何根据他的回答判断？**


1. **顶级候选人：** 提到**“重构前先补测试”**，提到**“代码要设计得易于 Mock”**。这种人你招进来，给他个文档，他一周内就能玩转 TDD。
2. **普通高级开发：** 认为 CR 就是查错别字，重构靠“细心”，测试靠“部署上去点点看”。这种人虽然经验多，但很难适应你的“高质量交付”要求，改变他的习惯会非常痛苦。
