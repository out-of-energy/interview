标号,类别,面试问题（人性化/场景化话术）,参考答案关键点（Checklist）,评分 (1-5)
1,线程池配置与避坑,“在生产环境中配置线程池时，关于核心线程数（CoreSize）和队列大小，你一般是怎么评估设置的？如果请求量突然把队列打满了，你们通常会选择哪种拒绝策略来兜底？”,1. 配置逻辑： 能区分 CPU密集型（N+1）与 IO密集型（2N 或更高），或提到根据压测调整。2. 队列隐患： 明确指出无界队列（如 LinkedBlockingQueue）可能导致 OOM。3. 拒绝策略： 熟悉 CallerRunsPolicy（降低提交速度）或 AbortPolicy（抛异常），能根据业务容忍度选择。,1 2 3 4 5
2,锁的选择与实战,“在解决线程安全问题时，你现在更倾向于用原本的 synchronized，还是 JUC 包里的 ReentrantLock 或 Atomic 类？什么特定的场景下，你会觉得必须放弃 synchronized 而改用 Lock？”,1. Synchronized： 知道 JDK1.6 后有偏向/轻量锁优化，性能不差，代码简洁。2. Lock 优势： 需要公平锁、需要响应中断、需要**尝试获取锁（tryLock）或多条件等待（Condition）时必须用 Lock。3. Atomic： 简单计数场景用 CAS 更快，但知道 ABA 问题。,1 2 3 4 5
3,异步编排与异常,“现在的业务逻辑越来越复杂，如果需要并行调用两三个接口然后聚合数据。你是习惯用 CountDownLatch 还是 CompletableFuture？如果其中一个子线程报错了或者超时了，你的主流程是怎么处理的？”,1. 工具演进： CompletableFuture 编排能力更强（链式调用、组合）；CountDownLatch 适合简单的一等地多。2. 容错意识： 必须提到异常捕获（exceptionally）或超时控制（orTimeout），不能让主线程一直傻等。3. 结果聚合： 知道 allOf 或 anyOf 的区别。,1 2 3 4 5
4,上下文传递隐患,“在微服务或 Web 开发中，我们常用 ThreadLocal 来存用户信息或 TraceID。在线程池复用线程的情况下，使用 ThreadLocal 会有什么严重的副作用？ 你们代码规范里是怎么强制规避这个问题的？”,1. 核心痛点： 线程复用导致“脏读”（上一个用户的数据遗留在线程里被下一个用户读到）和内存泄漏**。2. 解决方案： 必须遵循 “用完即清” 原则（在 finally 块中调用 remove()）。3. 加分项： 提到父子线程传递需用 InheritableThreadLocal 或阿里的 TTL。,1 2 3 4 5
5,线上故障排查,“假如线上服务突然 CPU 飙升到 100% 报警了，或者程序卡住不动了（疑似死锁）。你第一反应会用什么命令或工具去定位问题？ 请简述一下你的排查步骤。”,1. 标准步骤： top（找进程） -> top -Hp（找线程） -> printf %x（转16进制） -> jstack（抓堆栈）。2. 关键状态： 能识别堆栈中的 BLOCKED（死锁/锁竞争）或 RUNNABLE（死循环/计算密集）。3. 工具： 提到 Arthas（thread -n 3）或其他 APM 工具可加分。,1 2 3 4 5
