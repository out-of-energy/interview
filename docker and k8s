标号,类别,面试问题（人性化/场景化话术）,参考答案关键点（Checklist）,评分 (1-5)
1,Docker 镜像优化(构建效率),“我们在做 CI/CD 的时候，发现有些 Java 应用的镜像特别大，构建和传输都很慢。你写 Dockerfile 的时候，有什么具体的技巧能把镜像体积压到最小？”,1. 核心技巧： 必须提到 “多阶段构建” (Multi-stage builds)（编译环境和运行环境分离）。2. 基础镜像： 选用 Alpine 或 Distroless 等精简版镜像。3. 分层机制： 知道把不常变的命令（如安装依赖）放在前面利用缓存，变动频繁的代码放在后面。,1 2 3 4 5
2,K8s 资源限制(稳定性核心),“在给 Pod 配置 YAML 文件时，resources 里的 Requests 和 Limits 这两个参数，你是怎么理解和设置的？如果我不设置 Memory Limit，或者设置得太小，线上会发生什么可怕的事情？”,1. 区别： Requests 决定调度（节点有没有空地），Limits 决定硬上限（能不能超用）。2. 后果： 没限制可能导致单个 Pod 吃光节点内存，拖死整个 Node；设置太小会导致 OOMKilled（频繁重启）。3. Java特有： 提到 JVM 的堆内存（Xmx）必须小于容器的 Memory Limit，否则必挂。,1 2 3 4 5
3,健康检查与零宕机(部署质量),“有时候我们在发布新版本时，Pod 状态虽然显示 Running 了，但流量一切进来用户还是报错（502/连接拒绝）。这通常是因为缺了什么配置？ 你是怎么保证应用完全启动好之后，K8s 才会把流量转发给它的？”,1. 核心探针： 必须区分 Liveness Probe（存活探针，死则重启）和 Readiness Probe（就绪探针，死则切断流量）。2. 场景还原： 刚启动但 Spring Boot 还没初始化完数据库连接时，Readiness 应该由失败转为成功，K8s 才会接入 Service 流量。3. PreStop： 加分项，提到优雅停机（SIGTERM）处理。,1 2 3 4 5
4,故障排查 (CrashLoop)(运维能力),“如果你早上来上班，发现线上的某个 Pod 状态变成了 CrashLoopBackOff 或者 Pending。你不看代码，只用 kubectl 命令，你的排查思路是怎样的？”,1. 命令组合： kubectl describe pod xxx（看事件，如资源不足、挂载失败） + kubectl logs xxx（看应用报错）。2. Pending原因： 资源不足（CPU/内存不够调度）、节点污点（Taints）不匹配等。3. 进阶： 如果 Pod 启动就立刻退出了看不到日志，知道用 --previous 查看上一次崩溃的日志。,1 2 3 4 5
5,服务发现与网络(互联互通),“在 K8s 集群里，服务 A 想要调用服务 B。你是怎么配置它们之间的连接地址的？ 是写死 IP 吗？如果服务 B 扩容到了 10 个 Pod，服务 A 发出的请求是怎么分发给这 10 个 Pod 的？”,1. DNS 机制： 绝对不能写死 Pod IP，要用 Service Name（如 http://order-service）。2. 负载均衡： 知道 K8s Service（通常是 ClusterIP）自带简单的负载均衡（iptables/ipvs）。3. 外网暴露： 能简单区分 ClusterIP（内网）、NodePort（端口映射）、Ingress（域名/7层路由）的区别。,1 2 3 4 5
