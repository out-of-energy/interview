标号,类别,面试问题（人性化/场景化话术）,参考答案关键点（Checklist）,评分 (1-5)
1,集合底层 (HashMap)(数据结构),“HashMap 我们每天都用。我想问个细节：在 Java 8 之后，HashMap 解决 Hash 冲突的方式有了什么变化？如果有 10 万个对象存入 Map，性能很差，除了扩容，你觉得还有可能是因为 Key 对象的设计有什么问题？”,1. 结构演进： 必须答出 数组 + 链表 + 红黑树（当链表长度>8且数组长度>64时转红黑树），提升检索效率从 O(n) 到 O(log n)。2. Key 的隐患： hashCode 算法太烂导致所有 Key 都在一个桶里（退化成链表/树）；或者没有重写 equals 导致逻辑错误。3. 扩容机制： 知道 Load Factor (0.75) 和 2倍扩容带来的 Rehash 性能开销。,1 2 3 4 5
2,JVM 内存与 GC(性能基石),"“你刚才提到过 JVM 调优。对于一个高并发的 Web 服务，你通常会选择哪种垃圾回收器（CMS, G1, ZGC）？为什么？如果线上监控发现 Full GC 非常频繁（比如几分钟一次），你的第一直觉是哪里出了问题？”",1. GC 选型： JDK8 常用 G1（大堆、停顿时间可预测）；JDK11+ 考虑 ZGC（超低停顿）。2. Full GC 原因： 内存泄漏（对象没释放）、Metaspace 满了（类加载过多）、或者 System.gc() 被显式调用。3. 排查思路： 导出 Dump 文件，用 MAT 分析大对象。,1 2 3 4 5
3,对象引用与 OOM(内存管理),“我们在做缓存或者 ThreadLocal 的时候，如果不小心就会内存溢出。你了解 Java 的四种引用类型（强、软、弱、虚）吗？在做本地缓存（Local Cache）时，为了防止把内存撑爆，你会用哪一种引用类型？”,1. 区别： 强引用（死也不收）、软引用 (Soft)（内存不够才收，适合缓存）、弱引用 (Weak)（GC 一扫就收，适合 ThreadLocalMap）。2. 场景应用： 既然做缓存，如果不用 Caffeine/Guava，手写的话应该用 SoftReference 或 WeakReference，避免 OOM。,1 2 3 4 5
4,String 这一家子(不可变性),“String 应该是 Java 里最特殊的类了。为什么 Java 把它设计成不可变（Immutable）的？如果在循环里拼接字符串，你还在用 + 号吗？编译器现在虽然会优化，但在什么场景下我们必须手动用 StringBuilder？”,1. 设计哲学： 安全性（HashKey 唯一性、多线程安全）、字符串常量池（节省空间）。2. 拼接陷阱： 循环体内用 + 号会每次创建新的 StringBuilder 对象，导致大量临时对象 GC；必须在循环外 new StringBuilder。,1 2 3 4 5
5,Java 8+ 新特性(代码质量),“Stream 流操作写起来很爽，但也有坑。你在使用 parallelStream()（并行流）的时候有没有遇到过问题？什么情况下，并行流反而会比单线程的普通 for 循环还要慢？”,1. 线程池陷阱： 并行流默认使用全局 ForkJoinPool.commonPool()，容易被 IO 操作卡死导致全系统阻塞。2. 性能拐点： 数据量太小、装箱拆箱开销大、数据结构不易拆分（如 LinkedList）时，并行流不如 for 循环。3. 调试： Stream 也就是 lambda 表达式很难 Debug，这点要有认知。,1 2 3 4 5
